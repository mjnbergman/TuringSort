#include <wiringPi.h>

/// PINS ///
int chargePin = 13;
int dischargePin = 11; //speeds up discharging process, not necessary though
int measurePin = 2;

/// TIMER ///
unsigned long startTime;
unsigned long elapsedTime;

/// CALIBRATION VARS ///
const int sampleSize = 11;
unsigned long nullHypothesis;

/// COLOR VERIFICATION VARS ///
unsigned long blackish;
unsigned long whiteish;
bool firstWhite = true;
bool firstBlack = true;
bool secondWhite = true;
bool secondBlack = true;

bool detected = false;

/// ERROR VARS ///
int errorCount = 0; //counts measurements that aren't nothing nor whiteish nor blackish
const int TOLERANCE = 3;

/// ENUMS ///
enum Detected {BLACK, WHITE, NOTHING, EXIT};
enum Error {LED, LDR, DDISK};

/// SETUP FUNCTIONS ///
void sensorSetup(){
  //create null hypothesis

  //setup charging stuff initially
  pinMode(chargePin, OUTPUT);
  digitalWrite(chargePin, LOW);  
  //Serial.begin(9600); // Necessary to print data to serial monitor over USB

  calibrate();
}

void calibrate(){
  nullHypothesis = 0;
  //sampleSize = 11;
  unsigned long measurements[11];
  for(int i = 0; i < sampleSize; i++){
    doMeasurement(true); //10 iterations of loop
    measurements[i] = nullHypothesis;
  }
  
  //time passed to do sampleSize measurements
  sort(measurements, 11);
  nullHypothesis = measurements[5];
  //takes the mean of the measurements

  std::cout << "ready to start measuring with" << std::newl;
  std::cout << "null:" + nullHypothesis << std::newl;
}

/// MAIN LOOP FUNCTIONS ///
void sensorLoop(){
  doMeasurement(false);
}

void doMeasurement(bool isSetup){
  digitalWrite(chargePin, HIGH); // Begins charging the capacitor
  startTime = micros();

  bool chargeError = chargeCapacitor();
  if (chargeError) return;

  elapsedTime = micros() - startTime; // Determines how much time it took to charge capacitor
  if (isSetup) nullHypothesis = elapsedTime;
  
  stopChargingCapacitor();
  
  printDiagnostics();

  Detected d = determineColor();
  if (d == EXIT) return; //exit loop
  
  if (!isSetup){ //generate event (color or error) based on measurement, iff is not setup
    checkResult(d);
  }

  stopDischargingCapacitor();

}

Detected determineColor(){
  if(elapsedTime < 100){
    //happens when capacitor was not charged but still got here in execution. Shouldn't really happen, but in case it does...
    return NOTHING;
  } else if (elapsedTime < (0.8 * (float) nullHypothesis)) {

    if (!firstWhite && secondWhite){
      secondWhite = false;
      whiteish = elapsedTime;
    } 
    
    if (firstWhite){ //return to do another measure quickly
      firstWhite = false;
      redoIn(100);  
      return EXIT; //exit loop
    }

    return WHITE;
  } else if (elapsedTime > (1.2 * (float) nullHypothesis)){

    if (!firstBlack && secondBlack){
      secondBlack = false;
      blackish = elapsedTime;
    } 
    
    if (firstBlack){
      firstBlack = false;
      redoIn(100); 
      return EXIT; //exit loop  
    }
    
    return BLACK;
  } else {
    return NOTHING;
  }
}

void checkResult(Detected d){
  bool susValue = checkLEDs(elapsedTime, d);
  if (susValue) {
    errorCount++; //this color was not expected
    std::cout << "WARNING: LED(s) might be off." << std::newl;
  } else {
    errorCount = 0; //this color was expected
  }

  if (errorCount > TOLERANCE) {
    genErrorEvent(LED);
  } else {
    generateColorEvent(d);
  }  
}

/**
 * Prepares for doing another measurement after (ms). 
 * Cannot use delay because capacitor circuit must be prepared
 */
void redoIn(unsigned long ms) {
  long time_1 = millis();
  while (digitalRead(measurePin) == HIGH){
    bool error = LDRErrorGuard(time_1);
      if (error) {
        genErrorEvent(LDR);
        break;
      } //discharge
  }
  while (millis() - time_1 < ms); //delay ms while taking the other while in account
  pinMode(dischargePin, INPUT); // Prevents capacitor from discharging
}

/// CAPACITOR CONTROL FUNCTIONS ///
bool chargeCapacitor(){ //returns wether or not an error occured
  while (digitalRead(measurePin) == LOW) {
    //wait for the capacitor to charge the pin to HIGH
    bool error = LDRErrorGuard(startTime);
    if (error) {
      genErrorEvent(LDR);
      stopChargingCapacitor();
      stopDischargingCapacitor();
      return true; //exit loop
    }
  }
  return false;
}

void stopChargingCapacitor(){
  digitalWrite(chargePin, LOW); // Stops charging capacitor
  pinMode(dischargePin, OUTPUT); 
  digitalWrite(dischargePin, LOW); // Allows capacitor to discharge
}

void stopDischargingCapacitor(){
  unsigned long time_1 = micros();
  while (digitalRead(measurePin) == HIGH){
    //let the pin fully discharge, if not done already
    bool error = LDRErrorGuard(time_1);
    if (error){
      //an error was detected. Generate the error event, but also continue this method to properly reset the capacitor. Make sure no color event is generated by setting 'setup' to true
      genErrorEvent(LDR);
      break;
    }
  }
  pinMode(dischargePin, INPUT); // Prevents capacitor from discharging
}

/// DEZYNE EVENT GENERATORS ///
void generateColorEvent(Detected d){
  switch(d){
      case WHITE:
        genWhiteEvent(); delay(750); break;
      case BLACK:
        genBlackEvent(); delay(750); break;
      case NOTHING: 
        genNothingEvent(); break;
    }  
}

/**
 * DEZYNE EVENT GENERATOR
 */
void genWhiteEvent(){
  if (detected){ //saw a disk the very previous measure
      genErrorEvent(DDISK);
      return;
  }
  detected = true;
  std::cout << "WHITE" << std::newl; 
}

/**
 * DEZYNE EVENT GENERATOR
 */
void genBlackEvent(){
  if (detected){ //saw a disk the very previous measure
    genErrorEvent(DDISK);
    return;
  }
  detected = true;
  std::cout << "BLACK" << std::newl;
}

/**
 * DEZYNE EVENT GENERATOR
 */
void genNothingEvent(){
  detected = false;
  std::cout << "NOTHING" << std::newl;
  //do not need to generate an event for dezyne at the time
}

/**
 * DEZYNE EVENT GENERATOR
 */
void genErrorEvent(Error e){
  std::cout << "ERROR: ";
  switch(e){
    case LDR: std::cout << "LDR cannot make measurements at this time" << std::newl;  break;
    case LED: std::cout << "Light level has been changed after calibration." << std::newl; break;
    case DDISK: std::cout << "Concurrent disk detection is not allowed!" << std::newl; break;
  }  
}

/// ERROR CHECKERS ///
/**
 * Compare started time with current time (micros) 
 */
bool LDRErrorGuard(unsigned long started){
  return (micros() - started) > 1000000L; //true iff has been 1 second since started. LDR hasn't measured a thing. error!
}

/**
 * Returns wether or not a led mightve turned off
 */
bool checkLEDs(unsigned long colorValue, Detected d){
  switch(d){
    case WHITE: return (colorValue > 1.2 * whiteish || colorValue < 0.8 * whiteish); //color is more than 20% darker than before.
    case BLACK: return (colorValue > 1.2 * blackish || colorValue < 0.8 * blackish); //color is more than 20% darker than before.
    case NOTHING: return false; //fine no matter what
  }
}

/// MISC FUNCTIONS ///
void sort(unsigned long arr[], int n){
  //all these arrs are size 11, fortunately.
  int i, j;
  unsigned long key; 
    for (i = 1; i < n; i++) { 
        key = arr[i]; 
        j = i - 1; 
        /* Move elements of arr[0..i-1], that are 
          greater than key, to one position ahead 
          of their current position */
        while (j >= 0 && arr[j] > key) { 
            arr[j + 1] = arr[j]; 
            j = j - 1; 
        } 
        arr[j + 1] = key; 
    }
    return arr;
}

void printDiagnostics(){
  std::cout << (((float) elapsedTime / (float) nullHypothesis) * 100); std::cout << "%";
  std::cout << std::newl;
  std::cout << ("____") << std::newl;
  std::cout << ("blackish: "); std::cout << (((float) blackish / (float) nullHypothesis) * 100); std::cout << ("%") << std::newl; 
  std::cout << ("whiteish: "); std::cout << (((float) whiteish / (float) nullHypothesis) * 100); std::cout << ("%") << std::newl;
  std::cout <<("____") << std::newl;  
}

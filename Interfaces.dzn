extern String $std::string$;
extern int $int$;

interface iMotor
{
	in void turnClockwise();
	in void turnOff();
	in void turnCounterClockwise();
	
	enum State {Clock, Off, CounterClock};
	behaviour {
		
		State state = State.Off;
		
		[state.Clock] {
			on turnClockwise: illegal;
			on turnCounterClockwise: illegal;
			on turnOff: state = State.Off;
		}
		
		[state.Off] {
			on turnClockwise: state = State.Clock;
			on turnOff: {}
			on turnCounterClockwise: state = State.CounterClock;
		}
		
		[state.CounterClock] {
			on turnClockwise: illegal;
			on turnCounterClockwise: illegal;
			on turnOff: state = State.Off;
		}
	}
}

interface iOutput {
	in void turnOn();
	in void turnOff();
	in void output(in String output);
	
	behaviour {
		enum State {On, Off};
		State state = State.Off;
		
		[state.Off] {
			on turnOn: state = State.On;
			on turnOff: {}
			on output: illegal;
		}
		
		[state.On] {
			on turnOn: illegal;
			on turnOff: state = State.Off;
			on output: {}
		}
	}
}

interface iSensor {
	in void turnOn();
	in void turnOff();
	in void calibrate();
	out void measures(in int value);
	
	behaviour {
		enum State {On, Off};
		State state = State.Off;
		
		[state.Off] {
			on turnOn: state = State.On; 
			on turnOff: {}
			on calibrate: illegal;
		}
		
		[state.On] {
			on turnOn: illegal;
			on turnOff: state = State.Off;
			on calibrate: {}
			on inevitable: measures;
		}	
	}
	
}

interface iBlackWhiteSensor {
	in void turnOn();
	in void turnOff();
	in void calibrate();
	out void measuresBlack();
	out void measuresWhite();
	out void measuresError();
	
	behaviour {
		enum State {On, Off};
		State state = State.Off;
		
		[state.Off] {
			on turnOn: state = State.On; 
			on turnOff: {}
			on calibrate: illegal;
		}
		
		[state.On] {
			on turnOn: illegal;
			on turnOff: state = State.Off;
			on calibrate: {}
			on inevitable: measuresBlack;
			on inevitable: measuresWhite;
			on inevitable: measuresError;
		}	
	}
	
}

interface iControl {
	enum State {On, Off};
	in void turnOn();
	in void turnOff();
	
	behaviour {
		State state = State.Off;
		
		[state.Off] {
			on turnOn: state = State.On; 
			on turnOff: {}
		}
		[state.On] {
			on turnOn: illegal;
			on turnOff: state = State.Off;
		}
	}
}

interface iConveyerBelt {
	enum State {On, Off};
	enum Direction {Clockwise, CounterClockwise};
	in void turnOn();
	in void turnOff();
	in void setClockwise();
	in void setCounterClockwise();
	
	behaviour {
		State state = State.Off;
		
		[state.Off] {
			on turnOn: state = State.On;
			on turnOff: {}
			on setClockwise: {}
			on setCounterClockwise: {}
		}
		[state.On] {
			on turnOn: illegal;
			on turnOff: state = State.Off;
			on setClockwise: illegal;
			on setCounterClockwise: illegal;
		}
		
	}
	
}

interface CommunicationProtocol {
	in void sortMode();
//	in void errorsResolved();
//	in void startup();
//	in void shutdown();
	
	behaviour {
		on sortMode: {}
	}
}

interface iPusherControl {
	in bool box1();
	in bool box2();
	in bool box3();
	in bool wasteBox();
	in BoxState current();
	enum BoxState {Box1, Box2, Box3, WasteBox};
	
	behaviour {
		BoxState state = BoxState.WasteBox;
		
		on box1: { state = BoxState.Box1; reply(true); }
		on box1: reply(false);
		on box2: { state = BoxState.Box2; reply(true); }
		on box2: reply(false);
		on box3: { state = BoxState.Box3; reply(true); }
		on box3: reply(false);
		on wasteBox: { state = BoxState.WasteBox; reply(true); }
		on wasteBox: reply(false);
		on current: reply(state);
	}
}

interface iPusher {
	in void down();
	in void up();
	in bool isMoving();
	out void stopped();
	
	enum State {Down, Up};
	
	behaviour {
		bool moving = false;
		
		on isMoving: reply(moving); 
		[moving] {
			on inevitable: { stopped; moving = false; }
			on up: illegal;
			on down: illegal;
		} 
		[!moving] {
			on down: moving = true;
			on up: moving = true;
		}
	}
}

interface iTimer {
  in void createTimer();
  in void cancelTimer();
  out void timeout();

  behaviour {
    enum State {Idle, Busy};
    State state = State.Idle;

    [state.Idle] {
      on createTimer: {state = State.Busy;}
      on cancelTimer: illegal;
    }
    [state.Busy] {
      on createTimer: illegal;
      on cancelTimer: {state = State.Idle;}
      on inevitable: { timeout; state = State.Idle; }
    }
  }
}

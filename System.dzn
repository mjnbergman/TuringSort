import Interfaces.dzn;
import Components.dzn;

component System {
	provides CommunicationProtocol port;
	
	system {
		SortingApplication app;
		ConveyerBelt belt;
		BlackWhiteSensor sensor;
		Display display;
		PusherSystem pusherSystem;
		
		port <=> app.comms;
		belt.port <=> app.belt;
		sensor.port <=> app.sensor;
		display.port <=> app.output;
		pusherSystem.port <=> app.pushers; 
	}
}

component SortingApplication {
	provides CommunicationProtocol comms;
	requires iBlackWhiteSensor sensor;
	requires iOutput output;
	requires iConveyerBelt belt;
	requires iPusherControl pushers;
	
	behaviour {
		iConveyerBelt.State beltState = iConveyerBelt.State.On;
		enum OperationMode { Sort };
		OperationMode mode = OperationMode.Sort;
		
		
		/*
		 * On Startup, a certain series of events will need to be executed.
		 * This can be done in Dezyne, or, perhaps more fitting, in main.cc
		 */
		
		/*
		 * Perhaps a timer should be used here as well,
		 * to only read values after a timeout.
		 * This will be done to be sure that the pushers can be in the correct position,
		 * when requested.
		*/
		[mode.Sort && beltState.On] {
			on comms.sortMode(): {}
			on sensor.measuresBlack(): {
				bool s = pushers.box1();
				if (!s) {
					/*
					 * Slow down the belt... (if possible?)
					 * Then try again after a timeout
					 * If successful, then speed up again
					 * If not, stop all
					*/ 
				}
			}
			on sensor.measuresWhite(): {
				bool s = pushers.box2();
				if (!s) {
					/*
					 * Slow down the belt... (if possible?)
					 * Then try again after a timeout
					 * If successful, then speed up again
					 * If not, stop all
					*/ 
				}
			}
			on sensor.measuresError(): {
				// Measures a wrong object, eject in wasteBox
				bool s = pushers.wasteBox();
				if (!s) {
					/*
					 * Slow down the belt... (if possible?)
					 * Then try again after a timeout
					 * If successful, then speed up again
					 * If not, stop all
					*/ 
				}
			}
		}
	}
}